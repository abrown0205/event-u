{"ast":null,"code":"import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    this.handlersByElement = new Map();\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  isEmpty() {\n    return !this._active;\n  }\n\n  add(type, handler, opts, once = false, passive = false) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n\n    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {\n      opts = {\n        srcElement: opts\n      };\n    }\n\n    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n    let entries = handlersByElement.get(opts.srcElement);\n\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n\n    if (once) {\n      entry.once = true;\n    }\n\n    if (passive) {\n      entry.passive = true;\n    }\n\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    let insertPosition = entries.length - 1;\n\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n\n      insertPosition--;\n    }\n\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n\n    this._active = handlers.some(entry => !entry.passive);\n  }\n\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n\n    let target = event.srcEvent.target;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n\n      if (mjolnirEvent.handled) {\n        return;\n      }\n\n      target = target.parentNode;\n    }\n\n    this._emit(mjolnirEvent, 'root');\n  }\n\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler(Object.assign({}, event, {\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        }));\n\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/utils/event-registrar.js"],"names":["DEFAULT_OPTIONS","srcElement","priority","constructor","isEmpty","add","once","passive","handlersByElement","opts","Object","entries","entry","handlers","insertPosition","remove","i","handleEvent","mjolnirEvent","target","event","_emit","immediatePropagationStopped","stopPropagation","stopImmediatePropagation","entriesToRemove","handler","_normalizeEvent","rootElement","whichButtons","getOffsetPosition","handled"],"mappings":"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","sourcesContent":["import {whichButtons, getOffsetPosition} from './event-utils';\n\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n\n  add(type, handler, opts, once = false, passive = false) {\n    const {handlers, handlersByElement} = this;\n\n    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {\n      // is DOM element, backward compatibility\n      opts = {srcElement: opts};\n    }\n    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {type, handler, srcElement: opts.srcElement, priority: opts.priority};\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type, handler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode;\n    }\n    this._emit(mjolnirEvent, 'root');\n  }\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        handler(\n          Object.assign({}, event, {\n            type,\n            stopPropagation,\n            stopImmediatePropagation\n          })\n        );\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}